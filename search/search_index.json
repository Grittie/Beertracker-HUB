{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Smart Time Registration","text":""},{"location":"#what-is-a-time-registration-device","title":"What is a Time Registration Device?","text":"<p>The Smart Time Registration device is a tool used to track the ammount of time an employee has spent working, it can take on many forms. Traditionally, this was a a physical time clock where employees would 'punch in and out' their card, recording their hours manually.</p> <p>Nowadays, time registration devices are often available as websites or mobile apps. These tools can not only track overall work hours but also allow users to log time spent on specific tasks or projects. This tracking is then used for billing purposes, project management, and ensuring accurate payroll processing.</p>"},{"location":"#the-vision","title":"The vision","text":"<p>TODO: work on this I want the device to work like this and look something like this and work this way etc etc</p>"},{"location":"#project-requirements","title":"Project Requirements","text":"<p>(image will be changed  when better sketches are available)</p>"},{"location":"#embedded-device","title":"Embedded Device","text":"<p>For this project, the ESP32, along with other devices, will serve as the core component of the embedded product. Various sensors and peripherals, including an RFID scanner for scanning students' HVA IDs, buttons, and displays for data visualization, will be connected to the ESP32.</p>"},{"location":"#the-3-minimum-requirement-for-input-ouput-are","title":"The 3 minimum requirement for Input &amp; Ouput are:","text":"<p>INPUT:</p> <ol> <li> <p>RFID Scanner</p> </li> <li> <p>Buttons for increment and decrement (plus &amp; minus)</p> </li> <li> <p>On / Off Switch</p> </li> </ol> <p>Output:</p> <ol> <li> <p>LED Indicators</p> </li> <li> <p>LCD Screen</p> </li> <li> <p>Passive Buzzer</p> </li> </ol>"},{"location":"#website","title":"Website","text":"<p>The website will implement user registration using HVA IDs and passwords. Users will be listed with their clock-in and clock-out times for the day. Further developments and applications of this data are to be determined.</p>"},{"location":"#user-experience-design-cad","title":"User Experience Design (CAD)","text":"<p>The device will be housed in a compact enclosure designed using CAD, with the software OnShape.</p>"},{"location":"#market-research","title":"Market Research","text":"<p>Once the blueprint requirements are met, the device will be changed adding our own flavor and features. For example, a counter registration system will be integrated to track beverages, which will be added to a user database when they scan their pass. The device will also be integrated into a already running project \"BeerTracker\". </p>"},{"location":"#what-is-beertracker","title":"What is BeerTracker?","text":"<p>BeerTracker is a website designed, made and managed by Lars Grit for his class at the University of Applied Science of Amsterdam to keep a track of how many beers have been bought and drank to avoid the classic tradition of \"tikkies\". Using the BeerTracker the class is made aware of how much people are chipping in to keep the drinks even.</p> <p>During the implementation of this device the website will be heavily changed and updated.</p> <p></p>"},{"location":"#project-plan","title":"Project Plan","text":"<p>Throughout the duration of the project, I will be working on various aspects in parallel, rather than focusing on just one area each week. However, by the end of each week, I aim to have completed the specific tasks and milestones outlined for that week.</p>"},{"location":"#week-1-initial-setup","title":"Week 1: Initial Setup","text":"<ul> <li>Set up the fundamental components of the project, including hardware like the ESP32, RFID sensors, etc and environment, and software like setting up platformIO, Docker, and python for the Portfolio Website.</li> </ul>"},{"location":"#week-2-network-and-website-integration","title":"Week 2: Network and Website Integration","text":"<ul> <li>Connect the esp32 to the network and work on data communication.</li> <li>Setup REST-API</li> <li>Develop a basic website that interfaces with the clock-in and clock-out system, getting data from the database.</li> </ul>"},{"location":"#week-3-cad-housing-design","title":"Week 3: CAD Housing Design","text":"<ul> <li>Design and create a CAD model for the housing of the device to ensure everything fits well within the enclosure.</li> </ul>"},{"location":"#week-4-blueprint-finalization","title":"Week 4: Blueprint Finalization","text":"<ul> <li>Finalize the overall project blueprint, including diagrams, wiring, and database structure.</li> </ul>"},{"location":"#week-5-market-research-and-beer-tracker-integration","title":"Week 5: Market Research and Beer Tracker Integration","text":"<ul> <li>Conduct market research to assess project feasibility and potential features.</li> <li>Explore integration with beertracker.</li> </ul>"},{"location":"#week-6-user-experience-design-branding","title":"Week 6: User Experience Design &amp; Branding","text":"<ul> <li>Expand on the User Experience Design, focusing on improving usability and user interface.</li> <li>Start adding branding elements, making the project aesthetically appealing.</li> </ul>"},{"location":"#week-7-web-development","title":"Week 7: Web Development","text":"<ul> <li>Focus on refining the web interface, enhancing functionality, and integrating with beertracker.nl.</li> </ul>"},{"location":"#week-8-additional-features-alcohol-sensor","title":"Week 8: Additional Features (Alcohol Sensor)","text":"<ul> <li>Add nice-to-have features like an alcohol sensor to track usage and safety.</li> <li>Work on UED, web enhancements, and embedded system improvements for this new feature.</li> </ul>"},{"location":"#week-9-final-feedback","title":"Week 9: Final Feedback","text":"<ul> <li>Gather and implement feedback from peers, teachers, and potential users to fine-tune the system.</li> </ul>"},{"location":"#week-10-project-finalization","title":"Week 10: Project Finalization","text":"<ul> <li>Finalize the project, ensuring all features are tested, the device is functioning as intended, everything is documented, `and everything is ready for production.</li> </ul>"},{"location":"#use-of-ai","title":"Use of AI","text":"<p>The use of AI has been used writing this project to improve readability with better grammar </p>"},{"location":"journal/","title":"Learning journal","text":""},{"location":"journal/#week-1","title":"Week 1","text":"<p>In week one I tried to tackle a bunch of different aspects of the project. I choose the blueprint Smart Time Registration. and started planning out what I needed to create for this project. I have been keeping track of my tasks and ideas in Trello. </p> <p></p> <p>I setup the project using Docker, created a venv for python so I could run my portfolio website locally and started working on the Embedded part of the project first.</p> <p>I started creating my circuit in Fritzing and using the WeMOS which I later switched over to the ESP32-S3 after seeing that for the additional sensors and outputs I wanted to add still I would not have the available pins required on the WeMOS so I moved over to the ESP32.</p> <p></p> <p>I then built the circuit on my breadboard and wrote the code for it, and I was able to read the UID of the HvA passes.</p> <p></p> <p>I then moved my focus to writing the required documentation for the work I've done and shifted my focus on two other aspects of the project. The website and the User Experience Design. For the website I wanted to start with looking into how to make the database required for project and started making an ERD. This ERD still has to be worked on further and implemented. For User Experience Design I wanted to start learning how to use CAD and how to adapt CAD Designs to existing components.</p> <p>I took an LCD to start learning this, I looked up the datasheet where I was able to find the dimensions of the device and started sketching that out in OnShape where I could then design an enclosement around it.</p> <p> </p> <p></p>"},{"location":"journal/#feedback","title":"Feedback","text":"<p>\ud83e\uddf0 System Requirements (solved)</p> <p>Reviewer: Koen Lammers</p> <p>Feedback: It looks like a realy good page for your system requirement, realy detailed and covers all the parts of your system. Be sure to check them to yes when you finish one and also add the description with code on how you solved the problem!</p> <p>Takeaway: I should often revisit this page and see whether I've finished a requirement and properly document it when I do.</p> <p></p>"},{"location":"journal/#performance-review-week-1","title":"Performance Review Week 1","text":""},{"location":"journal/#week-2","title":"Week 2","text":"<p>Week two started with writing out my learning journal and figuring out how to tackle the feedback and also writing out a project plan with weekly goals and aspirations. This week was a lot of work building the website and making the required steps to achieve it. I started with the database where I used UML to figure out what data was required of this project to be in a database and sketched out an ERD. When that looked good I started making the EERD in MySQL Database from which I could generate my database.</p> <p></p> <p>With the database up and running it was time to start working on the website, this had to be done with the PHP, JS and HTML + CSS for styling. Using PHP I could make query's and calls to my database and encode it withing JSON which JS can fetch and work out it's information with it. I created a connection check that checks if the website has connection to the database and created a table which prints out all the users and their associated pass UID. </p> <p></p> <p>To secure the website and database I didn't want to have my credentials hard coded into the websites code so I had to learn how to expand my docker to install composer from which I could then install php packages like DOTENV which made it possible for me to store my database credentials in an only local file so other people could not have access to it.</p> <p>Having created a solid basis for the website I expanded my embedded part by adding a new output, the lcd screen. Getting it to work was a lot of trial and error. I used the i2c backpack which I had to solder unto the lcd screen itself. Using this I significantly lowered the amount of pins required to get the LCD display to work. My biggest struggle was to get the lcd display sufficiently powered since it requires 5v and the esp32 only has 3.3v output pins. This required me to use the 9v battery included in the IoT kit but not wanting to overpower the display I had to come to a solution to get the power from 9v to 5v for which I used a mini DCDC converter which gave me an output of 5v. </p> <p></p> <p>Lastly I have gotten my esp32 connected to the wifi using a wifi manager which makes it so I again don't have any potential important info saved in the code. I sketched out some more designs for my device and thought of fun additions and created the basis for my API. Which will handle the data calls from device to device.</p> <p></p> <p></p>"},{"location":"journal/#feedback_1","title":"Feedback","text":"<p>\ud83e\uddf0 Technical Documentations (unsolved)</p> <p>Reviewer: Melvin Moes</p> <p>Feedback: Looks good maybe add the prices to the component list. This way you could show a total price of making your system.</p> <p>Takeaway: I should add a column with prices, even though Melvin did not mention it I should change the BOM to places where I can purchase one from instead of where I got it. I should remove the HvA as supplier for example.</p> <p></p> <p>\ud83e\uddf0 Technical Documentations (unsolved)</p> <p>Reviewer: Koen Lammers</p> <p>Feedback: Be sure to add the url to the store pages! the rest looks clean and good!</p> <p>Takeaway: I should make sure to add links to the suppliers in the BOM to redirect them to the product.</p> <p></p> <p>\ud83c\udf10 Database (unsolved)</p> <p>Reviewer: Melvin Moes</p> <p>Feedback: Looks good except for some information is redundant. The datatypes should be excluded and the identifier should be underlined. (ERD)</p> <p>Takeaway: I should change the ERD and remove datatypes and underline identifiers, these steps should be implemented in the EER instead only.</p> <p></p> <p>\ud83c\udf10 Technical Documentation (unsolved)</p> <p>Reviewer: Nick Schokker</p> <p>Feedback: I like the structure of your technical documentation but i would say you can improve if you give a few visual example so its better to understand with the text</p> <p>Takeaway:  I should add short and concise code snippet to the technical doc aswell to make it more readable.</p> <p></p>"},{"location":"journal/#performance-review-week-2","title":"Performance Review Week 2","text":""},{"location":"journal/#week-3","title":"Week 3","text":"<p>Week 3 started with User Experience Design, by following a laser cutting workshop of Joey. Here I learnt how to use a lasercutting machine and what to look out for. Following this workshop I wanted to do more research in 2d and 3d cadding and followed a tutorial on 2d CADding which I could apply to laser cutting.</p> <p></p> <p>I then worked on embedded and getting it connected to the web, last week I got the esp32 connected to the wifi but now I had to figure out how to get it to send actual data. In php I started setting up the rest API to collect data from the esp32. and on the esp32 I had to figure out how to use post requests to send the data to my website through the API. Next step would be to collect data from the site to the esp32 for displaying user name on the LCD for example.</p> <p>For the embedded parts I had to figure out how to use capacitors and use it with the DCDC mini converter to get nice stable voltage flowing through the device and convert that batteries 9v to 5v for both powering the esp32 itself but also the DHT11 and LCD. I also added a DHT11 sensor that every so often updates the system by sending internal temperatures and humidity. Multiple LEDS for status showing power, wifi connection and card scanned and buttons for selecting modes.</p> <p>Along with updating the proper documentation for it and debugging the embedded hardware and software took two days time aswell.</p> <p></p> <p></p>"},{"location":"journal/#feedback_2","title":"Feedback","text":"<p>\ud83d\udc69\u200d\ud83c\udfa8 Concept &amp; Design (solved)</p> <p>Reviewer: Lucas Hilgevoord </p> <p>Feedback: I would brothen [broaden] your userbase a bit, so not only 3rd year students, but all the students of HvA. Looks good for the rest!</p> <p>Takeaway: I should change my userbase and scope to make the project available for all hva studenten since they will all have the hva ID's required to make the project.</p> <p></p> <p>\ud83d\udc69\u200d\ud83c\udfa8 Concept &amp; Design (unsolved)</p> <p>Reviewer:  Simon Sweerz</p> <p>Feedback: Ik denk dat het idee van SMART requirements is dat je meerdere requirements hebt, die allemaal SMART geformuleerd zijn. Voor de rest leg je goed uit voor wie beertracker is en waarvoor het is bedoelt.</p> <p>Takeaway: Ik moet meerdere smart doelen maken.</p> <p></p>"},{"location":"journal/#performance-review-week-3","title":"Performance Review Week 3","text":"<p>Sadly this week I got below average, due to much time spent on learning CAD and working on and debugging hardware I did not have enough commits. Combined with being sick and not attending school on the friday.</p> <p></p>"},{"location":"journal/#week-4","title":"Week 4","text":"<p>The week started with writing a lot of documentation, I was lacking behind especially with Concept &amp; Design (the feedback counted for week 3). The rest of week was primarily working on my api and embedded to get two communication working. This was a longer than anticipated task seeing how my esp32 also died during it and I didn't know for a whole day trying to debug. But I managed to create a two way communication where the esp32 sends the card UID and it receives the user's name associated with that UID, back from the api to display it on the LCD.</p> <p></p> <p></p>"},{"location":"journal/#feedback_3","title":"Feedback","text":"<p>\ud83d\udc69\u200d\ud83c\udfa8 Concept &amp; Design (unsolved)</p> <p>Reviewer: Koen Lammers</p> <p>Feedback: Hi Lars, please take into account that pla has a low glass transition point. this means that when your device is on a table on a sunny day, it might get soft or melt. for the summer it would be better to use a material like PETG, which has a higher glass transition temperature.</p> <p>Takeaway: For prototyping I can use PLA but for the end product it should be better to use PETG to ensure the encasing doesnt melt or get soft.</p> <p></p>"},{"location":"journal/#performance-review-week-4","title":"Performance Review Week 4","text":"<p>Sadly again, another week of below expectations. I put in the hours but due to a lot of debugging hardware this weekend with non functional esp32's and sickness lowering my productivity I'm not there 100% and it shows on the performance review.</p> <p></p>"},{"location":"journal/#week-5","title":"Week 5","text":"<p>This week I did a lot of work implementing the api and back-end logic for the clock in clock out system, in the form of sessions. Sessions are day(s) bound where users can check in and check out using the rfid scanner (tested using Postman to make post requests). Their timestamps are recorded and a total is adjusted. On the embedded side there has been a lot of research and rebuilding. To begin my esp32-s3 has been replaced by a esp32-32 after showing faulty activity, the reason why I picked the esp32-32 was due to the fact of the 5v output which resulted in not needing to use the 9v battery and the dcdc converter resulting in a simpler hardware setup.</p> <p></p> <p>With this implemented I was closing in on finishing my blueprint on the code and hardware side. However my RFID scanner is very inconsistent in it working, which lead to more research and replacing my rfid rc522 with a PN532 due to it's ability to work with i2c. The i2c protocol is already being used in the project for the LCD and works well, while the ISP connection of the old rfid scanner is very inconsistent.</p> <p>Last thing to be implemented was a heartbeat wifi connection to see if the esp32 is connected with the wifi and able to see it on the websites. The esp32 send an occasional heartbeat to the database with a healthy connection status and a timestamp. and on the website they look at the time stamp and see if it is in the websites frequency of (30 seconds).s</p> <p></p> <p></p>"},{"location":"journal/#feedback_4","title":"Feedback","text":"<p>\ud83c\udf10 API Reference (solved)</p> <p>Reviewer: Lucas Hilgevoord</p> <p>Feedback: Looks good! Nicely formatted :D</p> <p>Takeaway: N/A</p> <p></p>"},{"location":"journal/#performance-review-week-5","title":"Performance Review Week 5","text":""},{"location":"journal/#week-6","title":"Week 6","text":"<p>This week I was sick and absent.</p> <p></p>"},{"location":"journal/#performance-review-week-6","title":"Performance Review Week 6","text":""},{"location":"journal/#week-7","title":"Week 7","text":"<p>After healing from my sickness I started developing with the PN532 RFID sensor and making it work with i2c. I had to learn how to handle multiple i2c devices by using their specific i2c addresses. A lot of time was spent working on and debugging the code of the PN532 on multiple platforms to get a solid and consistent scanning workflow. </p> <p>The rest of the week was spent fully on UED with using CAD to create a physical housing for the device. I went through 15~ versions of the current design before landing on something that I was happy with and that worked and that I could use forward. It was not only a process of creating a design but also learning CAD itself and learning new techniques to further my project design. This also required a lot of trial and error getting parts to fit well and be placed well to keep enough space for every part.</p> <p></p> <p></p> <p>Multiple CAD design iterations</p> <p></p> <p></p> <p>Printed physical product</p> <p></p>"},{"location":"journal/#feedback_5","title":"Feedback","text":"<p>\ud83c\udf10 \ud83d\udc69\u200d\ud83c\udfa8 Concept &amp; Design (unsolved)</p> <p>Reviewer: Nick Schokkers</p> <p>Feedback: Looks good to me</p> <p>Takeaway: Helpful...</p> <p></p>"},{"location":"journal/#performance-review-week-7","title":"Performance Review Week 7","text":"<p> glu </p> <p>Made great progress today and the performance review looks good, sadly I didn't request enough feedback</p>"},{"location":"journal/#week-8","title":"Week 8","text":"<p>Week 8 begun with looking into my research for my project, I have two main subjects I'm working on further development with PCB design and Accesibility in UX, specifically the less fortunate in sight. In addition to exploring PCB design and accessibility, I investigating how humans react to specific sounds, which can be useful for implementing a buzzer in my project to deliver positive or negative feedback through different tones. Furthermore, I'm considering how Braille could be incorporated to enhance accessibility, alongside potential voice activation features that would allow users to interact with the device hands-free and without needing sight. This combination could significantly improve usability for visually impaired individuals. To test my product on accesibility aswell I started making up user tests for people to test my design and find edge cases and issue's people could have with the workflow of my device.</p> <p>I worked on implementing the buttons to work smoothly in my embedded code by giving a small enough delay for allowing people to hold down the button to cycle and using LCD visual and buzzer audible feedback on changing options. </p> <p>This week also included a massive website front-end overhaul using bootstrap, creating multiple tabs to divide the website and having a place for a dashboard to show fun and necessary information.</p> <p></p> <p>This week also involved significant CAD work, focusing on creating a custom bracket for the LCD that securely latches onto the main device. It was a challenging task to design a bracket that worked seamlessly within the device\u2019s size constraints, requiring careful adjustments to ensure both stability and functionality.</p> <p></p> <p>For the main device, I experimented with a fun drink-pattern design. I started by sketching and extruding patterns in alternating directions, then mirrored them for symmetry. Using Boolean tools, I refined the pattern by selectively intersecting and subtracting parts to create a cohesive, layered effect that mimics a bubbly drink texture.</p> <p>Creating the drink pattern turned out to be quite a challenge, largely due to the main device's rounded corners. Since the fillets were made as sketch fillets, working around them required careful alignment and extra precision to get the pattern to flow seamlessly across the curved edges. Integrating each layer without disrupting the filleted corners added a lot of complexity, but with iterative adjustments, I managed to achieve a cohesive design that maintained the bubbly, drink-like aesthetic.</p> <p></p> <p></p>"},{"location":"journal/#feedback_6","title":"Feedback","text":"<p>\ud83c\udf10 \ud83d\udc69\u200d\ud83c\udfa8 Concept &amp; Design (unsolved)</p> <p>Reviewer: Koen Lammers</p> <p>Feedback: </p> <p>Takeaway: </p> <p></p>"},{"location":"journal/#performance-review-week-8","title":"Performance Review Week 8","text":""},{"location":"journal/#week-9","title":"Week 9","text":"<p>Week 9 begun with</p> <p></p>"},{"location":"journal/#feedback_7","title":"Feedback","text":""},{"location":"journal/#performance-review-week-9","title":"Performance Review Week 9","text":""},{"location":"journal/#week-10","title":"Week 10","text":"<p>Week 10 begun with</p> <p></p>"},{"location":"system_architecture/","title":"System architecture","text":""},{"location":"system_architecture/#system-architecture","title":"System Architecture","text":""},{"location":"system_architecture/#introduction","title":"Introduction","text":"<p>The System Architecture Diagram provides an abstraction of the entire clock-in/clock-out system. It shows the interaction between the embedded system (ESP32-S3), frontend, backend, database, and the networking components. This diagram is essential to understand how the hardware and software components are connected, enabling smooth communication and efficient logging of user check-ins/outs and sensor data (e.g., temperature and humidity). This architecture also ensures the system is scalable and maintainable for future expansions.</p>"},{"location":"system_architecture/#component-breakdown-and-functionality","title":"Component Breakdown and Functionality","text":""},{"location":"system_architecture/#embedded-system-subsystem","title":"Embedded System (Subsystem)","text":"<ul> <li> <p>ESP32-S3-WROOM-1 (Hardware Component): The core microcontroller responsible for controlling the RFID scanning, user interaction through buttons and LEDs, and communicating with the backend system. It also handles temperature and humidity data acquisition via the DHT11 sensor.</p> </li> <li> <p>PN532 RFID Reader (Hardware Component): This module scans RFID cards and retrieves user information for clocking in and out. It communicates with the ESP32 via I2C.</p> </li> <li> <p>DHT11 Sensor (Hardware Component): A temperature and humidity sensor that continuously monitors the environment and sends data to the ESP32.</p> </li> <li> <p>Buzzer/LEDs (Hardware Components): Provide user feedback during operations, such as successful or failed RFID scans.</p> </li> <li> <p>C/C++ Program (Software Component): The firmware running on the ESP32 that handles input from the sensors, communication with the web server, and control of the system\u2019s outputs (LEDs, buzzer).</p> </li> </ul>"},{"location":"system_architecture/#webserver-subsystem","title":"Webserver (Subsystem)","text":"<ul> <li> <p>NGINX Web Server: Acts as a reverse proxy, directing traffic to the backend PHP services that handle API requests.</p> </li> <li> <p>PHP Module (Software Component): Responsible for processing HTTP requests, interacting with the database, and managing user sessions.</p> </li> </ul>"},{"location":"system_architecture/#frontend-subsystem","title":"Frontend (Subsystem)","text":"<ul> <li> <p>HTML Files (Software Components): Define the structure of the web interface where users can view their clock-in/clock-out records and session data.</p> </li> <li> <p>CSS Files (Software Components): Provide the styling and layout for the web interface.</p> </li> <li> <p>JavaScript Files (Software Components): Handle frontend logic, fetch data from the backend (using AJAX/HTTP requests), and update the page dynamically.</p> </li> <li> <p>Frontend PHP Files (Software Components): Handle the dynamic generation of the HTML content, ensuring the frontend is connected to the backend API.</p> </li> </ul>"},{"location":"system_architecture/#backend-subsystem","title":"Backend (Subsystem)","text":"<ul> <li> <p>API PHP Files (Software Components): These files handle the logic for user authentication, session management, and communication with the embedded ESP32 system. The <code>api.php</code> delegates requests to handlers (e.g., <code>temperature_handler.php</code>, <code>card_handler.php</code>, <code>session_handler.php</code>) based on the type of data being processed.</p> </li> <li> <p>Backend Libraries (Software Components): These libraries provide support for managing sessions, database queries, and user authentication.</p> </li> </ul>"},{"location":"system_architecture/#database-system-subsystem","title":"Database System (Subsystem)","text":"<ul> <li> <p>MariaDB Database: Stores all user data, RFID card associations, session logs, and temperature readings. Each session includes data like the check-in/check-out time and the number of pitchers.</p> </li> <li> <p>Database Instance: The actual instance running within a Docker container, handling all the persistent data storage.</p> </li> </ul>"},{"location":"system_architecture/#docker-registry-external-system","title":"Docker Registry (External System)","text":"<ul> <li>Docker Images: Pre-built containers for PHP, MariaDB, and supporting services, facilitating a portable and consistent environment across development and production.</li> </ul>"},{"location":"system_architecture/#docker-host-subsystem","title":"Docker Host (Subsystem)","text":"<ul> <li> <p>Docker Network (Virtual Hardware Component): Provides network communication between containers running the webserver, backend, and database services.</p> </li> <li> <p>Docker Containers (Virtual Hardware Component): Run the isolated instances of the webserver (NGINX + PHP) and MariaDB database.</p> </li> </ul>"},{"location":"system_architecture/#host-system-subsystem","title":"Host System (Subsystem)","text":"<ul> <li>Linux (or your specific host OS): The operating system running the Docker containers and managing the clock-in/clock-out system.</li> </ul>"},{"location":"system_architecture/#mobile-device-external-system","title":"Mobile Device (External System)","text":"<ul> <li> <p>Mobile OS (e.g., Android/iOS): Allows users to interact with the system via a web browser to view their clock-in and clock-out logs.</p> </li> <li> <p>Browser: Accesses the frontend web interface for monitoring and interacting with the system.</p> </li> </ul>"},{"location":"system_architecture/#network-access-point-external-system","title":"Network Access Point (External System)","text":"<ul> <li>Wi-Fi Access Point: Connects the ESP32 to the local network, enabling it to communicate with the backend server over HTTP.</li> </ul>"},{"location":"system_architecture/#internetintranet-abstraction","title":"Internet/Intranet (Abstraction)","text":"<ul> <li>Cloud Symbol: Represents the internet or intranet that connects the mobile devices and ESP32 to the server.</li> </ul>"},{"location":"system_architecture/#ssh-tunnel-subsystem","title":"SSH Tunnel (Subsystem)","text":"<ul> <li>SSH Tunnel: Provides secure remote access to the server, allowing you to manage and monitor the system from external networks.</li> </ul>"},{"location":"system_architecture/#communication-overview","title":"Communication Overview","text":"<ul> <li> <p>I2C Protocol (ESP32 &lt;-&gt; PN532, DHT11): Used for the ESP32 to communicate with the RFID reader and temperature sensor.</p> </li> <li> <p>HTTP Protocol (ESP32 &lt;-&gt; Webserver): The ESP32 sends RFID data, user credentials, and sensor data via HTTP requests to the PHP backend.</p> </li> <li> <p>HTTPS Protocol (Browser &lt;-&gt; Webserver): Users access the frontend interface over HTTPS to ensure secure transmission of data.</p> </li> <li> <p>MySQL Protocol (PHP Backend &lt;-&gt; MariaDB): Used by the backend PHP files to query and store data in the database.</p> </li> <li> <p>Docker Networking (Internal): Communication between Docker containers (NGINX, PHP, MariaDB) happens over an internal network using standard Docker networking mechanisms.</p> </li> </ul>"},{"location":"embedded/authentication/","title":"Authentication","text":""},{"location":"embedded/authentication/#configuration-header-file","title":"Configuration Header File","text":"<p>This project uses a <code>config.h</code> file to store sensitive credentials such as API usernames and passwords. This file is required for the project to build and run successfully.</p>"},{"location":"embedded/authentication/#step-1-copy-the-example-file","title":"Step 1: Copy the Example File","text":"<p>To set up the authentication file:</p> <ol> <li>Navigate to the <code>src</code> folder of the PlatformIO project.</li> <li>Locate the file named <code>config.h.example</code>.</li> <li>Copy and rename it to <code>config.h</code> in the same directory.</li> </ol>"},{"location":"embedded/authentication/#step-2-edit-the-configh-file","title":"Step 2: Edit the <code>config.h</code> File","text":"<p>Open the newly created <code>config.h</code> file and fill in the required credentials:</p> <pre><code>#ifndef CONFIG_H\n#define CONFIG_H\n\n// API username for authenticating with the server\n#define API_USERNAME \"your_actual_username\"\n\n// API password for authenticating with the server\n#define API_PASSWORD \"your_actual_password\"\n\n// API server address\n#define API_PASSWORD \"your_actual_address\"\n\n#endif\n</code></pre>"},{"location":"embedded/code/","title":"Embedded Code Documentation","text":"<p>This document provides a detailed explanation of the embedded code implementation found in the file <code>main.cpp</code>. The goal is to describe both the general functionality and specific elements of the code to provide a deeper understanding of its workings.</p>"},{"location":"embedded/code/#general-overview","title":"General Overview","text":"<p>The <code>main.cpp</code> file is the main entry point for an embedded system application. This code manages various functionalities of an IoT clock in and clock out system. The system is built around an ESP32-S3 microcontroller, which integrates multiple peripheral devices such as an RFID scanner, an I2C display, LEDs, buttons, and environmental sensors.</p> <p>The code is structured to set up all peripherals and handle their operations efficiently using tasks and interrupts, leveraging the FreeRTOS multithreading environment. The implementation is designed to manage different actions, such as user authentication, environmental monitoring, and session management, all of which are coordinated through the central processing flow in <code>main.cpp</code>.</p>"},{"location":"embedded/code/#code-structure","title":"Code Structure","text":""},{"location":"embedded/code/#1-libraries-and-constants","title":"1. Libraries and Constants","text":"<p>The code begins with importing the necessary libraries for handling different modules connected to the ESP32-S3, including: - Wire library for I2C communication. - SPI library for communication with RFID. - FreeRTOS-specific libraries for task management. - Custom header files that encapsulate specific device-related functionality like LCD, RFID, etc.</p> <p>Several constants are defined for pins used, such as the SDA, SCL pins for I2C devices, and GPIO pins for LEDs, buttons, and RFID communication.</p>"},{"location":"embedded/code/#2-setup-function","title":"2. Setup Function","text":"<p>The <code>setup()</code> function is where all initialization happens. The steps include: - Initializing Serial Communication: Primarily for debugging purposes. - RFID Initialization: The RFID sensor is initialized, and its configuration is verified. - Display Initialization: The I2C LCD screen is set up to display messages and provide feedback to the user. - Pin Configuration: The pins for LEDs and buttons are set as input or output as required. - WiFi Connection Setup: The code uses WiFiManager for connecting the ESP32 to the network, which enables communication with a backend server.</p>"},{"location":"embedded/code/#3-loop-function","title":"3. Loop Function","text":"<p>The <code>loop()</code> function typically contains the main execution cycle for an Arduino program, but in this case, it remains empty. Instead, the real functionality is executed using FreeRTOS tasks to achieve concurrent behavior.</p>"},{"location":"embedded/code/#4-freertos-task-management","title":"4. FreeRTOS Task Management","text":"<p>The implementation uses several FreeRTOS tasks: - RFID Reading Task: A task that continuously polls the RFID scanner to detect card taps and retrieve the UID. When a card is successfully scanned, the UID is sent to a backend server for validation and session management. - Environmental Monitoring Task: This task reads data from the DHT11 temperature and humidity sensor and sends the data to the backend periodically. - Display Update Task: Manages updating the LCD screen, such as displaying welcome messages, errors, or user-specific information when authenticated. - HTTP Server Task: This task sets up an HTTP server to handle incoming requests from the web interface.</p>"},{"location":"embedded/code/#5-button-handling-and-interrupts","title":"5. Button Handling and Interrupts","text":"<p>The code handles button presses using interrupts for better responsiveness. Two buttons are used to perform different actions: - Clock In Button: Assigned to GPIO pin 20, it allows users to check in when pressed. - Clock Out Button: The other button allows users to clock out of the system.</p> <p>Interrupt Service Routines (ISRs) are configured to detect rising edges for both buttons, which helps in quick and accurate user interaction.</p>"},{"location":"embedded/code/#6-wifi-communication-and-backend-integration","title":"6. WiFi Communication and Backend Integration","text":"<p>Data such as RFID UIDs and temperature readings are sent to the backend using HTTP requests. The backend API handles data such as temperature (<code>temperature_handler.php</code>) or user sessions (<code>session_handler.php</code>). The integration with the backend allows storing the data centrally and generating reports for logged sessions.</p>"},{"location":"embedded/code/#7-http-server-for-remote-reset","title":"7. HTTP Server for Remote Reset","text":"<p>The implementation includes an HTTP server task (<code>httpServerTask</code>) that enables remote interaction with the ESP32 through a web interface. One notable feature is the ability to reset the ESP32 remotely by sending an HTTP POST request to the <code>/reset</code> endpoint. When this endpoint is triggered, the server sends a response confirming the reset and then calls <code>ESP.restart()</code> to reset the microcontroller.</p> <p>This feature is particularly useful for remotely troubleshooting or rebooting the device without needing physical access, ensuring that any configuration changes or software updates can be applied effectively.</p> <pre><code>void httpServerTask(void *pvParameters) {\n    server.on(\"/reset\", HTTP_POST, [](AsyncWebServerRequest *request) {\n        request-&gt;send(200, \"text/plain\", \"ESP32 is resetting...\");\n        ESP.restart();\n    });\n\n    server.begin();\n\n    while (true) {\n        delay(1000);\n    }\n}\n</code></pre>"},{"location":"embedded/code/#8-error-handling","title":"8. Error Handling","text":"<p>Error handling is present in various functions, especially for device initialization and communication failures. If, for example, the RFID sensor fails to initialize, the system will show an error message on the display and prevent further operations until the error is resolved.</p>"},{"location":"embedded/code/#notable-features","title":"Notable Features","text":"<ul> <li>Multithreading with FreeRTOS: The use of FreeRTOS tasks enables the system to perform multiple actions simultaneously, such as scanning RFID tags while reading environmental data and updating the display.</li> <li>Real-Time Updates: The use of interrupts for buttons ensures that the system responds to user inputs in real time without noticeable delay.</li> <li>Backend API Communication: The ESP32 communicates with a backend server, enabling seamless logging of user sessions and temperature monitoring, which is essential for remote monitoring and analysis.</li> <li>Remote Reset Capability: The HTTP server task allows the ESP32 to be reset remotely, providing a convenient way to manage and troubleshoot the device.</li> </ul>"},{"location":"embedded/code/#link-to-code-repository","title":"Link to Code Repository","text":"<p>For further information, you can refer to the code available in the repository: main.cpp</p>"},{"location":"embedded/requirements/","title":"Requirements","text":"<p>This document outlines the hardware and functional requirements for the Smart Time Registration Device. The system is based on an ESP32-S3-DevKitC-1-N8R8 and is designed to handle RFID-based user identification, API communication, provide user interaction through buttons to cycle between actions, LEDs, and a buzzer.</p>"},{"location":"embedded/requirements/#hardware-components","title":"Hardware Components","text":"<ul> <li> <p>Microcontroller: ESP32-S3-DevKitC-1-N8R8  </p> </li> <li> <p>RFID Sensor: RFID-RC522 for scanning HVA IDs  </p> </li> <li> <p>LCD Display: 16x2 LCD with I2C Backpack  </p> </li> <li> <p>Buzzer: For feedback on card scan</p> </li> <li>LEDs: Multiple for system status indication</li> <li>Buttons: For switching between actions (e.g., Clock In, Clock Out, Start Break, End Break)</li> <li>Connectivity: Wi-Fi for making API calls to the website</li> </ul>"},{"location":"embedded/requirements/#functional-requirements","title":"Functional Requirements","text":""},{"location":"embedded/requirements/#1-rfid-scanning","title":"1. RFID Scanning","text":"<ul> <li>The system will use the RFID-RC522 RFID sensor to scan user HVA IDs.</li> <li>Upon scanning, the system will push the ID data via an API call.</li> </ul>"},{"location":"embedded/requirements/#2-api-communication","title":"2. API Communication","text":"<ul> <li>The ESP32-S3 will connect to the internet to make API calls:<ul> <li>Send scanned data (RFID) to the server.</li> <li>Receive user data (e.g., user name) in response and display on the LCD.</li> </ul> </li> </ul>"},{"location":"embedded/requirements/#3-display-and-feedback","title":"3. Display and Feedback","text":"<ul> <li>The LCD screen, connected via I2C, will show user information and action statuses.</li> <li>The buzzer will sound when a card is successfully scanned.</li> <li>LEDs will provide status indications for:<ul> <li>Power (system turned on)</li> <li>Internet connectivity (connected/disconnected)</li> <li>Card scan status (success/failure)</li> </ul> </li> </ul>"},{"location":"embedded/requirements/#4-user-input-and-actions","title":"4. User Input and Actions","text":"<ul> <li>The system will have buttons to switch between different actions:<ul> <li>Clock In</li> <li>Clock Out</li> <li>Start Break</li> <li>End Break</li> </ul> </li> </ul>"},{"location":"embedded/requirements/#inputs-and-outputs","title":"Inputs and Outputs","text":"Component Type Function ESP32-S3-DevKitC-1-N8R8 MCU Microcontroller to handle processing and communication. RC522 Input Reads RFID cards to identify users. LCD Display Output Displays the user name and system statuses. Buzzer Output Emits sound on successful card scan. LEDs Output Shows system status: Power, Internet Connectivity, and Card Scan result. Buttons Input Allows the user to switch between actions (Clock In, Clock Out, etc.)."},{"location":"embedded/requirements/#system-workflow","title":"System Workflow","text":"<ol> <li>Power On: System starts, LEDs indicate power and system status.</li> <li>Internet Connection: LED indicates when the system is connected to the internet.</li> <li>RFID Scan: User scans their ID card using the RC522 sensor.</li> <li>API Call: The ESP32-S3 sends the RFID data to the server via API.</li> <li>API Response: System receives user information and displays it on the LCD screen.</li> <li>Action Selection: User selects the action (Clock In/Out, Start/End Break) via buttons.</li> <li>Feedback: Buzzer sounds when a card is scanned, LEDs change based on status (e.g., card scan success).</li> </ol>"},{"location":"embedded/requirements/#dlo-requirements","title":"DLO Requirements","text":"Requirement ID# Requirement MoSCoW Compliant EMBRQ#01 The embedded device acts as a client and sends measured sensor data to the application backend over HTTP or HTTPS. MUST YES EMBRQ#02 The embedded device also acts as a server and receives status messages from the application backend over HTTP or HTTPS. MUST YES EMBRQ#03 The embedded device contains at least two types of input sensors (e.g. LDR, buttons, joystick, capacitive touch, etc.). MUST YES EMBRQ#04 The embedded device contains at least two types of visual and/or sensory outputs (e.g. LED, LED Matrix, 7-segment display, motor, servo, actuator, LCD-screen, buzzer, etc.). MUST YES EMBRQ#05 The embedded device uses the WifiManager for configuration of SSID and password (PWD) for connecting to the network. MUST YES"},{"location":"embedded/requirements/#embrq01","title":"EMBRQ#01","text":"<p>Requirement: The embedded device acts as a client and sends measured sensor data to the application backend over HTTP or HTTPS.</p> <p>Explanation: The code uses the <code>HTTPClient</code> library to send data to the backend API. This is implemented through a function that collects temperature and humidity data from the DHT sensor and then sends it using an HTTP POST request to the server.</p> <p>Code: <pre><code>#include &lt;HTTPClient.h&gt;\n#include &lt;DHT.h&gt;\n\n#define TEMP_SENSOR 26 // Analog Pin\n#define DHTTYPE DHT11  // DHT 11 type sensor\n\nDHT dht(TEMP_SENSOR, DHTTYPE);\n\nvoid sendSensorData() {\n    HTTPClient http;\n    String serverPath = \"http://your-server.com/api.php\";\n\n    // Read temperature and humidity\n    float temperature = dht.readTemperature();\n    float humidity = dht.readHumidity();\n\n    // Start connection and send HTTP header\n    http.begin(serverPath);\n    http.addHeader(\"Content-Type\", \"application/json\");\n\n    // Create JSON payload\n    String jsonPayload = \"{\"temperature\": \" + String(temperature) + \", \"humidity\": \" + String(humidity) + \"}\";\n    int httpResponseCode = http.POST(jsonPayload);\n\n    // End connection\n    http.end();\n}\n</code></pre></p>"},{"location":"embedded/requirements/#embrq02","title":"EMBRQ#02","text":"<p>Requirement: The embedded device also acts as a server and receives status messages from the application backend over HTTP or HTTPS.</p> <p>Explanation: The code uses the <code>ESPAsyncWebServer</code> library to create an HTTP server on the ESP32. The server can receive status messages from the backend, which are processed by specific request handlers.</p> <p>Code: <pre><code>#include &lt;ESPAsyncWebServer.h&gt;\n\nAsyncWebServer server(80);\n\nvoid setup() {\n    // Start server\n    server.on(\"/status\", HTTP_POST, [](AsyncWebServerRequest *request) {\n        String message;\n        if (request-&gt;hasParam(\"status\", true)) {\n            message = request-&gt;getParam(\"status\", true)-&gt;value();\n            // Handle status update\n        }\n        request-&gt;send(200, \"text/plain\", \"Status received\");\n    });\n    server.begin();\n}\n</code></pre></p>"},{"location":"embedded/requirements/#embrq03","title":"EMBRQ#03","text":"<p>Requirement: The embedded device contains at least two types of input sensors (e.g. LDR, buttons, joystick, capacitive touch, etc.).</p> <p>Explanation: The embedded device uses both an RFID sensor (<code>MFRC522</code>) and a DHT11 sensor as input devices. The RFID sensor is used to read card data, while the DHT11 sensor measures temperature and humidity.</p> <p>Code: <pre><code>#include &lt;MFRC522.h&gt;\n#include &lt;DHT.h&gt;\n\n#define SS_PIN 5    // SDA/SS Pin for SPI\n#define RST_PIN 17  // Reset Pin for SPI\n#define TEMP_SENSOR 26 // Analog Pin\n#define DHTTYPE DHT11  // DHT 11 type sensor\n\nMFRC522 mfrc522(SS_PIN, RST_PIN);\nDHT dht(TEMP_SENSOR, DHTTYPE);\n\nvoid setup() {\n    SPI.begin();\n    mfrc522.PCD_Init();\n    dht.begin();\n}\n</code></pre></p>"},{"location":"embedded/requirements/#embrq04","title":"EMBRQ#04","text":"<p>Requirement: The embedded device contains at least two types of visual and/or sensory outputs (e.g. LED, LED Matrix, 7-segment display, motor, servo, actuator, LCD-screen, buzzer, etc.).</p> <p>Explanation: The embedded device uses an LCD display (<code>LiquidCrystal_I2C</code>) to show status messages and a buzzer for auditory feedback. The LCD provides visual output, while the buzzer is used for alerts or notifications.</p> <p>Code: <pre><code>#include &lt;LiquidCrystal_I2C.h&gt;\n\n#define BUZZER_PIN 25 // Buzzer Pin\n\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\nvoid setup() {\n    lcd.init();\n    lcd.backlight();\n    pinMode(BUZZER_PIN, OUTPUT);\n\n    // Example usage\n    lcd.setCursor(0, 0);\n    lcd.print(\"Welcome!\");\n    digitalWrite(BUZZER_PIN, HIGH); // Sound the buzzer\n    delay(500);\n    digitalWrite(BUZZER_PIN, LOW);\n}\n</code></pre></p>"},{"location":"embedded/requirements/#embrq05","title":"EMBRQ#05","text":"<p>Requirement: The embedded device uses the WifiManager for configuration of SSID and password (PWD) for connecting to the network.</p> <p>Explanation: The <code>WiFiManager</code> library is used to manage the Wi-Fi connection. If no known SSID is found, the device will start an access point, allowing the user to configure the Wi-Fi credentials via a web interface.</p> <p>Code: <pre><code>#include &lt;WiFiManager.h&gt;\n\nvoid setup() {\n    WiFiManager wifiManager;\n    // Automatically connect using saved credentials, or start AP for configuration\n    wifiManager.autoConnect(\"BeertrackerAP\");\n}\n</code></pre></p>"},{"location":"embedded/technical_documentation/","title":"Technical documentation","text":""},{"location":"embedded/technical_documentation/#wiring-diagram","title":"Wiring Diagram","text":"<p>A wiring diagram shows how components are connected. It uses symbols for parts like resistors and power sources to illustrate connections and current flow, helping with troubleshooting.</p>"},{"location":"embedded/technical_documentation/#rfid-scanning-system","title":"RFID Scanning system","text":""},{"location":"embedded/technical_documentation/#breadboard-diagram","title":"Breadboard Diagram","text":""},{"location":"embedded/technical_documentation/#schematic-diagram","title":"Schematic Diagram","text":""},{"location":"embedded/technical_documentation/#bill-of-materials-bom","title":"Bill of Materials (BOM)","text":"<p>A BOM lists all components needed for a project, including names, quantities, and specifications. It acts as a checklist for sourcing parts and assembling the system.</p> Component Description Quantity Price (EUR) Supplier Purchase Link Perfboard Prototyping board for soldering components 1 \u20ac1.95 TinyTronics Perfboard 7x9cm - Single Sided Bambu Lab PLA Matte White Matte white PLA filament for 3D printing 1 $19.99 Bambu Lab Bambu Lab PLA Matte - Ivory White Bambu Lab PLA Basic Yellow Basic yellow PLA filament for 3D printing 1 $19.99 Bambu Lab Bambu Lab PLA Basic - Sunflower Yellow RFID RC522 Module RFID reader module for reading RFID tags 1 \u20ac4.95 TinyTronics RFID Kit MFRC522 S50 Mifare with Card and Key Tag 16x2 LCD Screen 16x2 character LCD display 1 \u20ac3.95 TinyTronics LCD1602 16x2 Character Display - Yellow/Green I2C Backpack for LCD I2C interface module for LCD screens 1 \u20ac1.95 TinyTronics I2C Interface Module for LCD1602 and LCD2004 Green LED 5mm green LED 1 \u20ac0.95 TinyTronics LED 5mm Green - 10 pieces Blue LED 5mm blue LED 1 \u20ac0.95 TinyTronics LED 5mm Blue - 10 pieces Red LED 5mm red LED 1 \u20ac0.95 TinyTronics LED 5mm Red - 10 pieces 1k\u03a9 Resistors 1k ohm resistors 5 \u20ac0.95 TinyTronics Resistor 1k\u03a9 - 10 pieces Passive Buzzer Passive piezoelectric buzzer 1 \u20ac0.95 TinyTronics Passive Buzzer Module Jumper Wires Male-to-male jumper wires for prototyping 1 set \u20ac2.95 TinyTronics Jumper Wires Male to Male - 65 pieces DHT11 Sensor Module Temperature and humidity sensor module 1 \u20ac2.95 TinyTronics DHT11 Temperature and Humidity Sensor Module ESP32 Development Board ESP32 microcontroller board with Wi-Fi and Bluetooth 1 \u20ac7.95 TinyTronics ESP32 Development Board - WiFi and Bluetooth Push Buttons Momentary push buttons 2 \u20ac0.95 TinyTronics Push Button 12x12mm - 5 pieces Capacitor Assortment Assorted electrolytic capacitors 1 set \u20ac4.95 TinyTronics Electrolytic Capacitor Assortment - 24 values USB-C Cable USB 2.0 cable A to USB-C, 1 meter 1 \u20ac2.95 TinyTronics USB 2.0 Cable A to USB-C - 1 meter USB-C Wall Adapter (5V 3A) 5V 3A USB-C power adapter 1 \u20ac7.95 TinyTronics USB-C Power Adapter 5V 3A Soldering Tin 0.8mm soldering tin, 100g 1 \u20ac9.95 TinyTronics Soldering Tin 0.8mm 100g"},{"location":"research/research_implementation/","title":"Research implementation","text":""},{"location":"research/research_to_market/","title":"Research to market","text":""},{"location":"research/research_to_market/#introduction","title":"Introduction","text":"<p>Imagine a group of friends enjoying a beer night together. One of them, Alex, is visually impaired. While his friends use the Beertracker HUB effortlessly to track their beer consumption, Alex faces significant challenges in interacting with the system. Current designs of Beertracker HUB do not account for individuals with visual impairments, which leaves people like Alex excluded from this shared experience. With accessibility becoming an increasingly important aspect of product design, addressing these challenges not only helps improve inclusion but also broadens the user base. Enhancing accessibility for visually impaired individuals is a meaningful pursuit, both from an ethical and market perspective, as it empowers a wider audience to fully engage with products. This research focuses on enhancing the accessibility of Beertracker HUB for blind users by proposing and evaluating practical improvements to the interface and interaction model.</p>"},{"location":"research/research_to_market/#research-question-and-sub-questions","title":"Research Question and Sub-Questions","text":"<p>Main Research Question: How can the Beertracker HUB be redesigned to make it more accessible for visually impaired users?</p> <p>Sub-Questions:</p> <ol> <li>What are the specific challenges faced by visually impaired users when interacting with the current Beertracker HUB interface?</li> <li>What are the best practices for designing accessible interfaces for blind users?</li> <li>How can audio feedback, tactile components, a braille display, and voice activation be integrated into Beertracker HUB to enhance usability?</li> <li>What technologies are available to support accessibility in embedded and physical systems?</li> </ol>"},{"location":"research/research_to_market/#research-methodology","title":"Research Methodology","text":"<p>To answer the research question and sub-questions, a mixed-method approach was used:</p> <ol> <li>User Interviews: Interviews were conducted with visually impaired individuals to identify the main challenges they face while using Beertracker HUB and similar products. These interviews aimed to gain qualitative insights into user needs, preferences, and pain points.</li> <li>Accessibility Testing: The current Beertracker HUB was tested by both visually impaired and sighted users. Accessibility experts were also consulted to evaluate the system and provide detailed feedback on usability issues.</li> <li>Literature Review: A review of existing literature on accessibility design, specifically for embedded systems and smart hubs, was performed. This helped identify best practices and successful design principles.</li> <li>Prototype Testing: A prototype with proposed modifications was developed and tested by users to evaluate the effectiveness of these changes. The prototype included audio feedback, a braille display, and voice activation features to assist navigation.</li> </ol>"},{"location":"research/research_to_market/#findings-and-evidence","title":"Findings and Evidence","text":"<p>The research revealed several key challenges:</p> <ul> <li>Interface Complexity: The current system heavily relies on visual cues, making it challenging for visually impaired users to interact with.</li> <li>Lack of Feedback: The Beertracker HUB lacks sufficient auditory or tactile feedback, which limits its accessibility for users who cannot rely on visual interaction.</li> <li>User-Centered Improvements: From user interviews, it became clear that blind users preferred clear, immediate auditory feedback when interacting with the system. Some users also suggested adding a braille display for tactile guidance and voice activation for hands-free interaction.</li> </ul> <p>To address these challenges, a prototype incorporating the following features was developed:</p> <ul> <li>Audio Feedback System: Audio prompts were added to guide users through the interaction process, such as confirming actions like beer logging or navigating through menu options.</li> <li>Tactile Buttons and Braille Display: Physical buttons with braille labels were added, along with a braille display to provide real-time information, enabling users to perform basic functions without needing to see the screen.</li> <li>Voice Activation: Voice commands were integrated into the system, allowing users to navigate menus and log beers hands-free, providing an additional layer of accessibility.</li> </ul> <p>User testing of the improved prototype showed a significant increase in satisfaction and ease of use among visually impaired participants. The inclusion of auditory feedback, tactile components, a braille display, and voice activation made the system much more user-friendly and intuitive.</p>"},{"location":"research/research_to_market/#reactions-to-different-buzzer-sounds","title":"Reactions to Different Buzzer Sounds","text":"<p>As part of the accessibility improvements, different buzzer sounds were tested to determine user reactions and preferences. The findings showed that the tone and type of buzzer sound could convey different types of feedback effectively:</p> <ul> <li>High-Pitched Tone for Positive Actions: A high-pitched, short buzzer sound was used to indicate positive actions, such as successfully logging a beer. Users responded positively to this sound, as it provided an immediate and clear indication of success.</li> <li>Low-Pitched Tone for Errors: A low-pitched, longer buzzer sound was used to indicate errors or invalid actions. This type of feedback helped users quickly understand when something had gone wrong, allowing them to adjust their actions accordingly.</li> <li>Rising Tone for System Ready: A rising tone sequence was used to indicate that the system was ready for input. This sound was found to be effective in signaling users to proceed with their actions.</li> <li>Falling Tone for Session End: A falling tone sequence was used to indicate the end of a session or when the user had completed their interaction. This provided a clear and satisfying conclusion to the interaction.</li> </ul> <p>The use of different buzzer sounds, combined with other feedback mechanisms, greatly enhanced the overall user experience by providing non-visual cues that were easy to interpret. This multi-modal approach helped ensure that blind users received clear and actionable feedback during their interaction with the Beertracker HUB.</p>"},{"location":"research/research_to_market/#proposed-improvements-and-implementation","title":"Proposed Improvements and Implementation","text":"<p>Based on the findings, the following improvements were proposed and documented on the portfolio website:</p> <ul> <li>Audio Feedback Integration: A module providing voice feedback for key actions, enabling blind users to understand what action has been performed.</li> <li>Braille-Enhanced Physical Interface and Display: Incorporating braille labels for all key buttons and a braille display for real-time system information, making the system more accessible.</li> <li>Voice Activation Feature: Adding voice commands to enable users to navigate the interface and log actions without the need for physical input.</li> <li>Simplified Navigation: Reducing the complexity of the menu to ensure that visually impaired users can quickly learn and use the system effectively.</li> <li>Buzzer Feedback System: Incorporating different buzzer tones to indicate positive actions, errors, readiness, and session end, providing users with immediate auditory cues that enhance interaction.</li> </ul> <p>The implementation of these features is documented with code explanations, images of the modified interface, and video demonstrations showing blind users interacting with the improved prototype.</p>"},{"location":"research/research_to_market/#conclusion","title":"Conclusion","text":"<p>This research addressed the main research question by demonstrating how the Beertracker HUB could be made more accessible for visually impaired users. The introduction of audio feedback, tactile components, a braille display, voice activation, and differentiated buzzer sounds significantly improved the usability of the system. Key findings showed that providing multiple forms of feedback\u2014auditory, tactile, and voice\u2014enabled a much more inclusive experience for blind users.</p> <p>Recommendations:</p> <ul> <li>Future improvements could include developing a mobile app that interfaces with Beertracker HUB, providing personalized voice control and further enhancing accessibility.</li> <li>Additional research could explore the use of machine learning to predict user actions and provide anticipatory assistance, further reducing barriers for visually impaired users.</li> </ul> <p>References: The research included a mix of up-to-date articles and books on accessibility design, case studies on accessible embedded systems, and guidelines from trusted organizations like the World Wide Web Consortium (W3C). Referencing was done consistently in APA style throughout the documentation.</p>"},{"location":"uxd/concept_design/","title":"Concept &amp; Design","text":""},{"location":"uxd/concept_design/#concept","title":"Concept","text":"<p>The Smart Check in / out system is being developed for beertracker.nl , a platform used by students of the Amsterdam University of Applied Sciences (HvA). The system helps track beer ordering so that everyone pays equally without needing to request payments after the fact.</p>"},{"location":"uxd/concept_design/#main-goal","title":"Main Goal","text":"<p>As an HvA student using beertracker.nl, my primary goal is to ensure that the consumption and ordering of beer is tracked accurately so I can pay my fair share without having to manually calculate or request payments from others. I want a simple and efficient way to clock in when I start drinking and clock out when I'm done, knowing that the system will automatically track how much I've ordered and what I owe, ensuring fair and equal payments among all participants.</p>"},{"location":"uxd/concept_design/#product-requirements","title":"Product Requirements","text":"<p>The clock in and clock out system for beertracker.nl will meet the following SMART requirements:</p> <p>Specific:</p> <ul> <li>The system must enable users (HvA students) to clock in when they start drinking and clock out when they finish.</li> <li>It must track each user's drinking session, log the start and end times, and calculate the total beer ordering for each user.</li> </ul> <p>Measurable:</p> <ul> <li>The system must record at least 95% of drinking sessions without error and provide clear consumption and payment data for each user.</li> <li>It will display the total number of users who have clocked in, total consumption per session, and individual ordering per user.</li> <li>The system will update the main dashboard and provide a history of each session.</li> </ul> <p>Achievable:</p> <ul> <li>The system will use RFID tags to allow users to clock in and out quickly, minimizing manual input.</li> <li>It will integrate with the existing beertracker.nl website to synchronize consumption data in real-time.</li> </ul> <p>Relevant:</p> <ul> <li>The system directly addresses the students' need for a fair, automated way to track beer consumption.</li> <li>It reduces the complexity of keeping track of who owes what, ensuring a hassle-free experience for social drinking events.</li> </ul> <p>Time-bound:</p> <ul> <li>The system will be fully implemented and tested by the end of the 10-week project period.</li> </ul>"},{"location":"uxd/concept_design/#users","title":"Users","text":"<p>The primary users of this system are HvA students in their third year. They need a system that can accurately track the order of beer in a fair and automated way, ensuring that payments are distributed equally among all users.</p>"},{"location":"uxd/concept_design/#scope","title":"Scope","text":"<ul> <li>The system will only be used by HvA students in their (current) third year.</li> <li>The scope includes beer (pitcher) order tracking, clocking in and out of sessions, and easy access to consumption data.</li> </ul>"},{"location":"uxd/concept_design/#user-needs","title":"User Needs","text":""},{"location":"uxd/concept_design/#smart-goals","title":"SMART Goals","text":"<ul> <li>Specific: The system must allow students to clock in when they start drinking and clock out when they stop, accurately logging consumption times and calculating how much each person owes.</li> <li>Measurable: The system should record the number of users and total beer consumption during each session.</li> <li>Achievable: The solution will be implemented using RFID scanning of HvA IDs to make clocking in and out simple and quick.</li> <li>Relevant: This system directly addresses the problem of unequal beer consumption and payment confusion among students.</li> <li>Time-bound: The system should be operational by the end of the 10-week project period.</li> </ul>"},{"location":"uxd/concept_design/#digital-manufacturing-material","title":"Digital Manufacturing &amp; Material","text":"<p>For the Smart Check in / out system encasing, I will be 3D printing the housing using PLA (Polylactic Acid) on my personal Bambu Labs A1 Mini due to its ideal properties for this type of project.</p> <p></p>"},{"location":"uxd/concept_design/#material-properties","title":"Material Properties","text":"<ul> <li> <p>Strength: PLA provides fine structural integrity for a device that won't be used in high-impact environments. It will also be mobile and not have to weather the elements. However, if more structural strength is required, I have the option to use carbon-infused filament, which offers enhanced durability and stiffness.</p> </li> <li> <p>Ease of Use: PLA is easy to print and works well with the Bambu Labs A1 Mini, making it perfect for quickly prototyping and iterating the design. It is odorless, inexpensive, and readily available.</p> </li> <li> <p>Precision: With the A1 Mini, the design details such as RFID scanner cutouts, button placements, and ventilation for sensors will be aligned with high accuracy, ensuring a perfect fit.</p> </li> <li> <p>Environmental Consideration: PLA is eco-friendly, being derived from renewable resources and can be reformed into more spools.</p> </li> <li> <p>Speed of Production: The Bambu Labs A1 Mini is a fast and reliable printer, allowing me to quickly produce and test multiple versions of the enclosure.</p> </li> </ul> <p></p>"},{"location":"uxd/concept_design/#design-sketches","title":"Design Sketches","text":""},{"location":"uxd/concept_design/#digital-design","title":"Digital Design","text":"<p>For the digital design of the encasing, I am using Onshape, a cloud-based CAD platform. Onshape provides several advantages for this project:</p> <ul> <li>Browser-Based Access: Since Onshape runs entirely in a web browser, I can access and modify my designs from any device with an internet connection, eliminating the need for specialized hardware or software installations.</li> <li>Ease of Use: Its intuitive interface and powerful set of tools make creating complex 3D models straightforward, ensuring the encasing design fits all internal components accurately.</li> <li>Version Control: Onshape tracks every change made to the design, allowing me to easily revert to previous versions or compare different iterations.</li> <li>Plug-In Support: Onshape allows for easy integration of plug-ins, enabling me to extend functionality with additional tools and features as needed during the design process.</li> </ul> <p>All CAD designs related to this project can be found in the /cad folder in the root directory of this project, where each design iteration is documented and available for review.</p>"},{"location":"uxd/concept_design/#cad-design","title":"CAD Design","text":"<p>All versions of the design files that were created and that are described in this documentation can be found in the /cad folder in the root of the project.</p>"},{"location":"uxd/conclude_reflect/","title":"Conclude &amp; Reflect","text":""},{"location":"uxd/conclude_reflect/#conclude","title":"Conclude","text":""},{"location":"uxd/conclude_reflect/#reflect","title":"Reflect","text":"<p>The DHT11 burnt through </p> <p>The original casing was too small I needed a pcb</p>"},{"location":"uxd/create_test/","title":"Create &amp; Test","text":""},{"location":"uxd/create_test/#test-details","title":"Test Details","text":"<ul> <li>Date: 06-11-2024</li> <li>Tester Name: Lucas</li> <li>Test Conducted By: Lars</li> <li>Test Location: HvA</li> </ul>"},{"location":"uxd/create_test/#physical-check-inout-test","title":"Physical Check-In/Out Test","text":""},{"location":"uxd/create_test/#goal","title":"Goal:","text":"<p>Test the process of checking in and out with the physical BeerTracker hub.</p>"},{"location":"uxd/create_test/#instructions","title":"Instructions:","text":"<ol> <li>Approach the BeerTracker hub.</li> <li>Follow the instructions provided to check in and check out.</li> <li>Record observations about ease of use, clarity, and speed.</li> </ol>"},{"location":"uxd/create_test/#user-feedback","title":"User Feedback","text":"<ul> <li>Was the process easy to understand? </li> <li>[x] Yes</li> <li>[ ] No</li> <li>Was the check-in/check-out process intuitive? </li> <li>[x] Yes</li> <li>[ ] No</li> <li>Comments on the physical item usability (e.g., button placement, display readability, etc.): </li> <li>the button are loose</li> </ul>"},{"location":"uxd/create_test/#suggestions-for-improvement","title":"Suggestions for Improvement:","text":"<ul> <li>make the menu selector faster</li> </ul>"},{"location":"uxd/create_test/#website-interaction-test","title":"Website Interaction Test","text":""},{"location":"uxd/create_test/#goal_1","title":"Goal:","text":"<p>Test the account creation and UID update processes on the BeerTracker website.</p>"},{"location":"uxd/create_test/#instructions_1","title":"Instructions:","text":"<ol> <li>Navigate to the BeerTracker website.</li> <li>Register a new account.</li> <li>Update the UID for the newly created account.</li> <li>Record observations about ease of navigation, clarity of instructions, and speed.</li> </ol>"},{"location":"uxd/create_test/#user-feedback_1","title":"User Feedback","text":"<ul> <li>Was the account creation process straightforward? </li> <li>[x] Yes</li> <li>[ ] No</li> <li>Was the UID update process easy to locate and complete? </li> <li>[x] Yes</li> <li>[ ] No</li> <li>Comments on website usability (e.g., button placement, navigation, form clarity): </li> <li>the tabs are clear</li> </ul>"},{"location":"uxd/create_test/#suggestions-for-improvement_1","title":"Suggestions for Improvement:","text":"<ul> <li>make it so the topbar goes back to dashboard</li> </ul>"},{"location":"web/api_reference/","title":"API Reference","text":"<p>This documentation provides a detailed overview of all available API endpoints in the system. Each endpoint's purpose, method, URL, parameters, and response structure are described to facilitate integration and usage.</p>"},{"location":"web/api_reference/#api-endpoints","title":"API Endpoints","text":""},{"location":"web/api_reference/#post-endpoints","title":"POST Endpoints","text":"<ol> <li> <p>Handle Card Session</p> <ul> <li>Endpoint: <code>/api/card</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>RFID_Tag</code> (string): Unique identifier for the RFID card.</li> <li>Description: Processes session data associated with a card (RFID).</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Session processed successfully.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Handle Device Address</p> <ul> <li>Endpoint: <code>/api/address</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>device_id</code> (string): Identifier for the device.</li> <li><code>address</code> (string): Address details to be stored.</li> <li>Description: Stores or updates the device address information.</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Device address updated successfully.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Handle Heartbeat</p> <ul> <li>Endpoint: <code>/api/heartbeat</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>device_id</code> (string): Identifier of the device sending the heartbeat.</li> <li>Description: Logs a heartbeat signal from a device.</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Heartbeat recorded successfully.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Handle Device Connection</p> <ul> <li>Endpoint: <code>/api/connection</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>device_id</code> (string): Identifier of the connected/disconnected device.</li> <li><code>status</code> (string): Status of the device (e.g., \"connected\", \"disconnected\").</li> <li>Description: Registers the connection status of a device.</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Device connection status recorded.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Add Session Data</p> <ul> <li>Endpoint: <code>/api/session</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>UserID</code> (int): User ID for session entry.</li> <li><code>CheckInTime</code> (datetime): Time of check-in.</li> <li><code>CheckOutTime</code> (datetime): Time of check-out.</li> <li>Description: Records session data including check-in and check-out times for users.</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Session data recorded successfully.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Handle Temperature Data</p> <ul> <li>Endpoint: <code>/api/temperature</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>temperature</code> (float): Temperature reading from the device.</li> <li><code>humidity</code> (float): Humidity reading from the device.</li> <li>Description: Stores temperature readings from devices.</li> <li>Response Example:   <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Temperature data recorded.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Add New User</p> <ul> <li>Endpoint: <code>/api/add_user</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>name</code> (string): Name of the new user.</li> <li><code>role</code> (string): Role of the user (e.g., \"admin\", \"user\").</li> <li><code>rfid_tag</code> (string): RFID tag associated with the user.</li> <li>Description: Adds a new user with associated RFID tag information.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"message\": \"User added successfully.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Edit User</p> <ul> <li>Endpoint: <code>/api/edit_user</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>userID</code> (int): ID of the user to edit.</li> <li><code>name</code> (string): Updated name of the user.</li> <li><code>role</code> (string): Updated role of the user.</li> <li><code>rfid_tag</code> (string): Updated RFID tag.</li> <li>Description: Edits user details including name, role, and RFID tag.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"message\": \"User details updated.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Delete User</p> <ul> <li>Endpoint: <code>/api/delete_user</code></li> <li>Method: POST</li> <li>Parameters:</li> <li><code>userID</code> (int): ID of the user to delete.</li> <li>Description: Deletes a user from the database.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"message\": \"User deleted.\"\n}\n</code></pre></li> </ul> </li> </ol>"},{"location":"web/api_reference/#get-endpoints","title":"GET Endpoints","text":"<ol> <li> <p>Get Connection Status</p> <ul> <li>Endpoint: <code>/api/connection</code></li> <li>Method: GET</li> <li>Description: Retrieves connection status of all devices.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"connections\": [\n        { \"deviceId\": \"ESP32-001\", \"status\": \"connected\" },\n        { \"deviceId\": \"ESP32-002\", \"status\": \"disconnected\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get Heartbeat Status</p> <ul> <li>Endpoint: <code>/api/heartbeat</code></li> <li>Method: GET</li> <li>Description: Fetches latest heartbeat data from devices.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"heartbeat\": \"Device heartbeat status retrieved.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Get Device Address</p> <ul> <li>Endpoint: <code>/api/address</code></li> <li>Method: GET</li> <li>Description: Retrieves the address information of a device.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"address\": \"Device address retrieved.\"\n}\n</code></pre></li> </ul> </li> <li> <p>Get Latest Check-in</p> <ul> <li>Endpoint: <code>/api/latest_checkin</code></li> <li>Method: GET</li> <li>Description: Returns the most recent check-in data.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"latest_checkin\": { \"UserID\": \"1\", \"CheckInTime\": \"2024-11-06 08:00\" }\n}\n</code></pre></li> </ul> </li> <li> <p>Get Latest Connection</p> <ul> <li>Endpoint: <code>/api/latest_connection</code></li> <li>Method: GET</li> <li>Description: Retrieves the latest connection status updates.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"latest_connection\": { \"deviceId\": \"ESP32-001\", \"status\": \"connected\" }\n}\n</code></pre></li> </ul> </li> <li> <p>Get Latest Temperature</p> <ul> <li>Endpoint: <code>/api/latest_temperature</code></li> <li>Method: GET</li> <li>Description: Fetches the latest temperature and humidity reading.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"temperature\": \"23.5\",\n    \"humidity\": \"60\"\n}\n</code></pre></li> </ul> </li> <li> <p>Get Temperature and Humidity Logs</p> <ul> <li>Endpoint: <code>/api/temperature_humidity</code></li> <li>Method: GET</li> <li>Description: Retrieves the last 60 temperature and humidity records.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"data\": [\n        { \"timestamp\": \"2024-11-05 14:00\", \"temperature\": \"23.5\", \"humidity\": \"60\" },\n        { \"timestamp\": \"2024-11-05 13:00\", \"temperature\": \"22.8\", \"humidity\": \"58\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get Leaderboard</p> <ul> <li>Endpoint: <code>/api/leaderboard</code></li> <li>Method: GET</li> <li>Description: Provides a leaderboard based on user session data.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"leaderboard\": [\n        { \"UserID\": \"1\", \"name\": \"Alice\", \"totalPitchers\": \"5\" },\n        { \"UserID\": \"2\", \"name\": \"Bob\", \"totalPitchers\": \"4\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get All Sessions</p> <ul> <li>Endpoint: <code>/api/session</code></li> <li>Method: GET</li> <li>Description: Lists all session entries with details for each user.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"sessions\": [\n        { \"SessionID\": \"1\", \"UserID\": \"1\", \"CheckInTime\": \"08:00\", \"CheckOutTime\": \"17:00\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get Time Registration Data</p> <ul> <li>Endpoint: <code>/api/time_registration</code></li> <li>Method: GET</li> <li>Description: Retrieves time registration data for users.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"registrations\": [\n        { \"UserID\": \"1\", \"name\": \"Alice\", \"role\": \"admin\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get Users</p> <ul> <li>Endpoint: <code>/api/users</code></li> <li>Method: GET</li> <li>Description: Lists all users with role and RFID data.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"users\": [\n        { \"UserID\": \"1\", \"name\": \"Alice\", \"role\": \"admin\", \"RFID_Tag\": \"123456\" }\n    ]\n}\n</code></pre></li> </ul> </li> <li> <p>Get Cumulative Statistics</p> <ul> <li>Endpoint: <code>/api/cumulative_statistics</code></li> <li>Method: GET</li> <li>Description: Provides cumulative statistics on sessions and users.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"cumulative_data\": { \"total_sessions\": \"10\", \"total_hours\": \"50\" }\n}\n</code></pre></li> </ul> </li> <li> <p>Get Pitcher Statistics</p> <ul> <li>Endpoint: <code>/api/pitcher_statistics</code></li> <li>Method: GET</li> <li>Description: Provides statistics about pitcher consumption, including total pitchers, money spent, and top consumers.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"pitcher_data\": {\n        \"total_pitchers\": \"100\",\n        \"total_money_spent\": \"1400\",\n        \"pitchers_per_session\": \"2.5\",\n        \"most_pitchers_session_date\": \"2024-11-01\",\n        \"most_pitchers_in_session\": \"5\"\n    }\n}\n</code></pre></li> </ul> </li> <li> <p>Get Pitcher Consumption per User</p> <ul> <li>Endpoint: <code>/api/pitcher_consumption</code></li> <li>Method: GET</li> <li>Description: Retrieves consumption data showing pitchers consumed per user.</li> <li>Response Example:   <pre><code>{\n    \"success\": true,\n    \"pitcher_consumption\": [\n        { \"name\": \"Alice\", \"total_pitchers\": \"10\", \"total_sessions\": \"5\" },\n        { \"name\": \"Bob\", \"total_pitchers\": \"8\", \"total_sessions\": \"4\" }\n    ]\n}\n</code></pre></li> </ul> </li> </ol>"},{"location":"web/code/","title":"Web Code","text":""},{"location":"web/code/#introduction","title":"Introduction","text":"<p>The BeerTracker HUB project is a modern web-based dashboard built to facilitate the tracking and management of user sessions and beer pitcher consumption. This documentation provides a comprehensive overview of how the project is structured, highlighting the various technologies used and how they adhere to the latest standards in web development. It is aimed at developers who wish to understand the codebase or contribute to future development.</p>"},{"location":"web/code/#repository","title":"Repository","text":"<p>You can access the code repository here.</p>"},{"location":"web/code/#front-end-overview","title":"Front-End Overview","text":"<p>The front-end of BeerTracker HUB is built using HTML, CSS, and JavaScript, following modern web standards to create a responsive and accessible user experience. The front-end is structured into HTML files for the layout, CSS for styling, and JavaScript for interactions.</p>"},{"location":"web/code/#html","title":"HTML","text":"<p>The main structure of the website is contained in the <code>index.html</code> file. The HTML is organized to display various dashboard components like session statistics, pitcher activity, the leaderboard, and account management features.</p> <p>Key features: - Use of Bootstrap for styling and responsiveness. - Custom components for different parts of the dashboard, such as sessions, accounts, and the leaderboard. - Utilization of HTML in PHP files for including common components like navigation and layout elements.</p> <p>File: <code>index.html</code></p>"},{"location":"web/code/#css","title":"CSS","text":"<p>The styling is managed through a separate CSS file, <code>style.css</code>, which helps ensure a clean separation of concerns. The CSS includes: - Custom styling for the database connection states, navbar, tables, and various cards used throughout the dashboard. - The color scheme primarily uses shades of yellow and gold to maintain brand consistency. - Imported Google Fonts to enhance the visual appeal of the text.</p> <p>File: <code>style.css</code></p> <pre><code>/* Colours for database connection states */\n#database-connection.success {\n    color: green;\n}\n#database-connection.failed {\n    color: red;\n}\n</code></pre> <p>This snippet demonstrates how different states are highlighted visually for better user experience\u301014\u2020source\u3011.</p>"},{"location":"web/code/#javascript","title":"JavaScript","text":"<p>The JavaScript is organized into a separate file, <code>script.js</code>, which contains all the logic for interacting with the back-end API. The JavaScript primarily uses the Fetch API to get and send data, ensuring that all data interactions are done asynchronously for better performance.</p> <p>Key features: - Functions like <code>fetchSessionData()</code>, <code>fetchTemperatureData()</code>, and <code>fetchLeaderboardData()</code> make API calls to fetch data and update the UI accordingly. - The JavaScript code adheres to the convention of defining functions to handle specific tasks and grouping data by date, sessions, and other attributes for easier UI updates. - JSON is used as the primary data format for all requests and responses, following REST API best practices.</p> <p>File: <code>script.js</code></p> <pre><code>// Fetch connection status and update the UI\nfunction fetchConnectionStatus() {\n    fetch('api/connection')\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            const connectionStatus = document.getElementById('database-connection');\n            if (data.success) {\n                connectionStatus.innerHTML = `successful (Fetching .env from ${data.directoryPath})`;\n                connectionStatus.className = \"success\";\n            } else {\n                connectionStatus.innerHTML = `failed: ${data.error}`;\n                connectionStatus.className = \"failed\";\n            }\n        })\n        .catch(error =&gt; {\n            console.error('Error:', error);\n            connectionStatus.innerHTML = `failed: ${error}`;\n            connectionStatus.className = \"failed\";\n        });\n}\n</code></pre> <p>The above function is responsible for fetching and displaying the connection status to the back-end, updating the UI with the appropriate success or failure message\u301013\u2020source\u3011.</p>"},{"location":"web/code/#back-end-overview","title":"Back-End Overview","text":"<p>The back-end of the BeerTracker HUB project is written in PHP, following an object-oriented programming (OOP) structure. This helps keep the code modular and maintainable.</p>"},{"location":"web/code/#api","title":"API","text":"<p>The API is designed to handle requests from the front-end, interacting with the database to read, insert, update, or delete data. All routes return JSON-formatted responses to ensure consistency and ease of use on the front-end.</p> <p>Key features: - Separate handler files for different functionalities (<code>embedded_handler.php</code>, <code>getters.php</code>, <code>setters.php</code>). - Each route in the API handles specific tasks, such as user management, session tracking, or temperature data retrieval. - Utilization of PHP's OOP features to create modular, reusable components.</p>"},{"location":"web/code/#php-conventions","title":"PHP Conventions","text":"<p>The code follows PHP conventions strictly, ensuring readability and maintainability: - Separation of Concerns: Different aspects of the application logic are handled by separate files. - Error Handling: Errors are caught and returned in JSON format to avoid breaking the application with unexpected HTML output. - Object-Oriented Programming: Classes are used to encapsulate related functionality, making the code more modular.</p> <p>File: <code>db_connect.php</code></p>"},{"location":"web/code/#database-integration","title":"Database Integration","text":"<p>The database is connected to the back-end using PHP, and all interactions with it are done through the API. Key features of the integration: - Insertions and Updates: For example, new users can be added through the <code>add_user</code> route, and user details can be edited using the <code>edit_user</code> route. - Data Fetching: Routes like <code>get_temperature</code>, <code>get_sessions</code>, and <code>get_leaderboard</code> allow the front-end to fetch up-to-date information. - Error Handling: All database interactions are wrapped in try-catch blocks, with errors returned as JSON.</p>"},{"location":"web/code/#api-endpoints","title":"API Endpoints","text":"<p>The API provides multiple endpoints that the front-end uses to interact with the database. Some of these are: - <code>api/session</code> (GET): Fetches all sessions grouped by date. - <code>api/users</code> (GET): Fetches user data for the account management tab. - <code>api/edit_user</code> (POST): Edits the details of a specific user. - <code>api/add_user</code> (POST): Adds a new user to the database. - <code>api/temperature_humidity</code> (GET): Fetches the historical temperature and humidity data for charting.</p> <p>All API routes are designed to return JSON-formatted responses, adhering to RESTful standards, and ensuring a clean, consistent interface between the front and back ends.</p>"},{"location":"web/code/#summary","title":"Summary","text":"<p>The BeerTracker HUB project follows modern web development standards by leveraging HTML, CSS, and JavaScript for a responsive front-end, while PHP and MySQL are used for a modular, object-oriented back-end. The code is structured to ensure a clear separation of concerns, enhancing maintainability and scalability.</p> <p>The entire project is aimed at providing users with a seamless experience in tracking sessions, managing users, and analyzing consumption data. All aspects, from front-end UI interactions to back-end database management, are implemented following the latest best practices in the industry.</p>"},{"location":"web/database/","title":"Database","text":"<p>I have created an ERD using dbdiagram that can create visuals from text input, both text input and visuals are added below.</p>"},{"location":"web/database/#erd","title":"ERD","text":"<pre><code>Table users {\n  id int [primary key, note: 'User ID']\n  name varchar(255) [note: 'User name']\n  role varchar(100) [note: 'User role (e.g., Employee, Manager)']\n  created_at timestamp [default: `now()`]\n}\n\nTable cards {\n  id int [primary key, note: 'Card ID']\n  user_id int [not null, ref: &gt; users.id, note: 'Associated user ID']\n  rfid_tag varchar(255) [unique, note: 'RFID tag']\n  status varchar(50) [default: 'Active']\n  issue_date date\n  expiry_date date\n}\n\nTable sessions {\n  id int [primary key, note: 'Session ID']\n  user_id int [not null, ref: &gt; users.id, note: 'Associated user ID']\n  session_date date [not null]\n  check_in_time time [not null]\n  check_out_time time\n  pitchers int [default: 0, note: 'Pitcher count']\n  total_hours float [note: 'Calculated total hours']\n}\n\nTable attendance_logs {\n  id int [primary key, note: 'Log ID']\n  card_id int [not null, ref: &gt; cards.id, note: 'Associated card ID']\n  timestamp datetime [not null]\n  event_type enum('Clock In', 'Clock Out') [not null]\n}\n\nTable internal_temperature {\n  id int [primary key, note: 'Temperature Log ID']\n  timestamp datetime [not null]\n  temperature float [not null]\n  humidity float [not null]\n}\n\nTable connection_status {\n  id int [primary key]\n  timestamp datetime [default: `CURRENT_TIMESTAMP`]\n  status varchar(20)\n}\n\nTable heartbeats {\n  id int [primary key, note: 'Heartbeat ID']\n  timestamp datetime [default: `CURRENT_TIMESTAMP`]\n  status varchar(20) [default: 'Active']\n}\n\nTable activity_log {\n  id int [primary key, note: 'Activity Log ID']\n  timestamp datetime [default: `CURRENT_TIMESTAMP`]\n  activity_type varchar(50) [not null]\n  description varchar(255)\n}\n\nTable device_information {\n  id int [primary key]\n  timestamp datetime [default: `CURRENT_TIMESTAMP`]\n  ip varchar(45) [not null]\n  mac varchar(17) [not null]\n}\n</code></pre>"},{"location":"web/database/#eer","title":"EER","text":"<p>Using mysqldatabase I've created an EER with all the proper fields, relations and specifiers</p> <p></p>"},{"location":"web/database/#sql","title":"SQL","text":"<p>From the previously made EER I can generate a mysql querry to create the database.</p> <pre><code>CREATE DATABASE smart_time_registration;\nUSE smart_time_registration;\n\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    role VARCHAR(100)\n);\n\nCREATE TABLE cards (\n    card_id INT AUTO_INCREMENT PRIMARY KEY,\n    user_id INT NOT NULL,\n    rfid_tag VARCHAR(255) UNIQUE NOT NULL,\n    status VARCHAR(50) DEFAULT 'Active',\n    issue_date DATE,\n    expiry_date DATE,\n    FOREIGN KEY (user_id) REFERENCES users(user_id)\n        ON DELETE CASCADE\n        ON UPDATE CASCADE\n);\n\nCREATE TABLE sessions (\n    session_id INT AUTO_INCREMENT PRIMARY KEY,\n    user_id INT NOT NULL,\n    session_date DATE NOT NULL,\n    check_in_time TIME NOT NULL,\n    check_out_time TIME,\n    pitchers INT DEFAULT 0,\n    total_hours FLOAT GENERATED ALWAYS AS (\n        TIMESTAMPDIFF(SECOND, CONCAT(session_date, ' ', check_in_time), CONCAT(session_date, ' ', check_out_time)) / 3600\n    ) STORED,\n    FOREIGN KEY (user_id) REFERENCES users(user_id)\n        ON DELETE CASCADE\n        ON UPDATE CASCADE\n);\n\nCREATE TABLE attendance_logs (\n    log_id INT AUTO_INCREMENT PRIMARY KEY,\n    card_id INT NOT NULL,\n    timestamp DATETIME NOT NULL,\n    event_type ENUM('Clock In', 'Clock Out') NOT NULL,\n    FOREIGN KEY (card_id) REFERENCES cards(card_id)\n        ON DELETE CASCADE\n        ON UPDATE CASCADE\n);\n\nCREATE TABLE internal_temperature (\n    temp_log_id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME NOT NULL,\n    temperature FLOAT NOT NULL,\n    humidity FLOAT NOT NULL\n);\n\nCREATE TABLE connection_status (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(20)\n);\n\nCREATE TABLE heartbeats (\n    heartbeat_id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    status VARCHAR(20) DEFAULT 'Active'\n);\n\nCREATE TABLE activity_log (\n    activity_id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    activity_type VARCHAR(50) NOT NULL,\n    description VARCHAR(255)\n);\n\nCREATE TABLE device_information (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    ip VARCHAR(45) NOT NULL,\n    mac VARCHAR(17) NOT NULL\n);\n</code></pre>"},{"location":"web/database/#step-by-step-guide-for-using-the-sql-script","title":"Step-by-Step Guide for Using the SQL Script","text":"<ol> <li> <p>Clone the Repository: Begin by cloning the GitLab project repository to your local machine.    <pre><code>git clone git@gitlab.fdmci.hva.nl:IoT/2024-2025-semester-1/individual-project/zuuliiyiizoo76.git\n</code></pre></p> </li> <li> <p>Access the SQL Script: Navigate to the SQL script file in the project directory.    <pre><code>cd zuuliiyiizoo7/web/php/\n</code></pre></p> </li> <li> <p>Database Creation: Open your MySQL client, then run the SQL script to set up the database.    <pre><code>SOURCE smart_time_registration.sql;\n</code></pre></p> </li> <li> <p>Verify Database Setup: Check that all tables are created successfully by listing the tables in the <code>smart_time_registration</code> database:    <pre><code>USE smart_time_registration;\nSHOW TABLES;\n</code></pre></p> </li> </ol>"},{"location":"web/database/#accessing-the-sql-script","title":"Accessing the SQL Script","text":"<p>You can find the SQL script in the GitLab project repository at the following link:</p> <p>SQL Script on GitLab</p>"},{"location":"web/technical_documentation/","title":"Technical Documentation","text":"<p>This documentation outlines the implementation of the website for the Smart Time Registration project. The website serves as a front-end interface to interact with the time registration system, allowing users to view their registration details and check the database connection status.</p>"},{"location":"web/technical_documentation/#design-decisions","title":"Design Decisions","text":"<p>This project was designed with modularity, scalability, and user-friendliness in mind. The key design decisions include:</p> <ul> <li>Separation of Concerns: HTML, CSS, and JavaScript are kept in separate files, which helps in better maintainability and follows best practices in web development.</li> <li>Object-Oriented PHP: The use of OOP in PHP ensures that different parts of the back-end code are reusable and easy to extend.</li> <li>Use of REST API: The decision to use REST API endpoints allows for a clear separation between the front-end and back-end, making the application scalable and easy to maintain.</li> <li>Bootstrap Framework: Bootstrap was used to create a responsive user interface, ensuring that the application works well on different screen sizes.</li> </ul>"},{"location":"web/technical_documentation/#target-audience-considerations","title":"Target Audience Considerations","text":"<p>The website was designed specifically for the students of my class. Given this target audience, the interface needed to be intuitive and straightforward, enabling users to easily track sessions, view statistics, and manage accounts without requiring extensive technical knowledge. By incorporating familiar UI elements and clear navigation, the design aims to provide a seamless user experience that suits the needs of the student group.</p>"},{"location":"web/technical_documentation/#challenges-and-solutions","title":"Challenges and Solutions","text":"<ul> <li>Data Synchronization: Keeping the front-end updated with real-time data from the back-end was a challenge. This was solved by using JavaScript's <code>setInterval()</code> function to periodically fetch data and update the UI.</li> <li>Database Connection Issues: There were initial issues with establishing a stable connection to the database, which were solved by implementing a robust error-handling mechanism in <code>db_connect.php</code> to log and return errors in a consistent format.</li> <li>Ensuring Consistent UI Updates: To avoid performance issues, data fetching was modularized into specific functions that only update relevant parts of the UI, minimizing reflows and improving the user experience.</li> </ul>"},{"location":"web/technical_documentation/#technologies-used","title":"Technologies Used","text":"<ul> <li>HTML, CSS, JavaScript: These were used to build the front-end and provide interactivity.</li> <li>PHP: Used for the back-end to create API routes and interact with the database.</li> <li>MySQL: The relational database used to store user sessions, temperature data, and other related information.</li> <li>Bootstrap: Used for styling and responsive design.</li> <li>Chart.js: Utilized to create charts for visualizing temperature and pitcher consumption data.</li> <li>Docker: The deployment environment was containerized using Docker, ensuring consistency across different stages of development, testing, and production.</li> <li>GitLab: Version control was managed through GitLab, providing effective collaboration and CI/CD pipelines for efficient deployment.</li> </ul>"},{"location":"web/technical_documentation/#contemporary-developments-in-web-development","title":"Contemporary Developments in Web Development","text":"<p>The project incorporates contemporary developments in web development to ensure it is up to date with modern practices: - Asynchronous Data Fetching: The use of JavaScript's Fetch API and periodic updates with <code>setInterval()</code> align with modern standards of creating interactive, real-time web applications. - Responsive Design: Bootstrap was used to ensure the website is fully responsive, providing an optimal user experience across devices of various screen sizes, from desktops to smartphones. - RESTful API Design: Following RESTful principles ensures that the front-end and back-end are loosely coupled, making it easier to maintain and extend functionality in the future.</p>"},{"location":"web/technical_documentation/#website-structure","title":"Website Structure","text":"<p>The website is organized into distinct tabs for easy navigation:</p> <ul> <li>Dashboard Tab: Displays cumulative session data and pitcher activity statistics.</li> <li>Sessions Tab: Allows users to view detailed session records.</li> <li>Account Management Tab: Administer user accounts, including adding, editing, or removing users.</li> <li>Leaderboard Tab: Shows top users based on pitcher consumption and attendance.</li> </ul> <p>Each of these components interacts with the back-end via the API, ensuring that the front-end always displays the latest data from the database.</p>"},{"location":"web/technical_documentation/#api-structure","title":"API Structure","text":"<p>The back-end API is split into multiple components for better organization and maintainability:</p> <ul> <li>Getters: These are responsible for fetching data from the database, such as user information, session details, temperature, and humidity data. The getters are designed to handle read-only operations, ensuring that the correct data is served to the front-end.</li> <li>Setters: These handle the creation and updating of data in the database. Examples include adding new users, editing user information, or logging new session entries. The setters follow best practices in data validation to ensure data integrity.</li> <li>Embedded Handlers: These provide specific functionalities related to hardware integration, such as fetching data from IoT devices. These handlers are responsible for processing the embedded device requests and updating the database accordingly.</li> </ul>"},{"location":"web/technical_documentation/#testing","title":"Testing","text":"<p>The application was tested thoroughly to ensure functionality and usability:</p> <ul> <li>Unit Testing: Individual functions in the back-end were tested to ensure they worked correctly in isolation.</li> <li>Integration Testing: The interaction between the front-end and back-end was tested by simulating API requests from JavaScript.</li> <li>User Testing: The interface was tested by several users to ensure that it was intuitive and met their expectations.</li> <li>Error Handling: Extensive error handling was implemented to make sure that all API routes returned appropriate JSON responses even in case of failures.</li> </ul>"},{"location":"web/technical_documentation/#deployment","title":"Deployment","text":"<p>The BeerTracker HUB was deployed on a cloud server to ensure availability and scalability. Key steps for deployment included:</p> <ul> <li>Docker Containers: Docker was used to containerize the application, ensuring that all dependencies were consistently configured across environments. This made it easier to deploy, scale, and manage the application.</li> <li>Server Setup: A Linux server with Apache was set up to host the Docker containers.</li> <li>Database Configuration: MySQL was used for storing data, and its instance was also containerized within Docker for ease of management.</li> <li>Version Control: GitLab was used for version control, providing CI/CD pipelines that facilitated seamless integration and deployment of new features.</li> </ul>"}]}